binary file の reader と writer を作ろう。
template Haskell と quasi quotation を活用することにする。
まずは簡単な例から。

data 構造と reader を自動生成するようにする。
つまり、
[binary|

BitmapFileHeader

2: 19778
4: fileSize
2: 0
2: 0
4: offset

|]

と書くと、

data BitmapFileHeader = BitmapFileHeader {
	fileSize :: Int,
	offset :: Int
 }

という構造と、

readBitmapFileHeader :: String -> BitmapFileHeader
readBitmapFileHeader cs = let
	cs' = if 19778 == readInt $ take 2 cs then drop 2 cs else error "bad"
	fs = readInt $ take 4 cs'
	cs'' = drop 4 cs'
	cs''' = if 0 == readInt $ take 2 cs'' then drop 2 cs'' else error "bad"
	cs'''' = if 0 == readInt $ take 2 cs''' then drop 2 cs''' else error "bad"
	os = readInt $ take 4 cs'''' in
	BitmapFileHeader {
		fileSize = fs,
		offset = os
	 }

という reader を生成するようにしたい。

まずは data 構造からだ。

次は連続する同一の構造への対応だ。

[binary|

BitmapFileHeader

2: 19778
4: fileSize
2: 0
2: 0
4: offset
4: 40
4: bitmapWidth
4: bitmapHeight
2: 1
2: bitPerPic
4: compress
4: imageDataSize
4: horizontalDensity
4: verticalDensity
4: colorIndexNumber
4: neededIndexNumber
4[colorIndexNumber]: colors

bitPerPic/8[imageDataSize*8/bitPerPic]: colors
bitPerPic b[imageDataSize*8/bitPerPic]: colors

|]

とすることにしよう。
また、それが難しかったら、まずは

[binary|

...
4[256]: colors

|]

という記述から始めようか。

また、行く行くは bytes ではなく bits でも指定できるようにしたい。

4b: some
4b: other
1: someOther

といった感じに。

あと空行を許すようにしよう。

4[256]: colors の場合:

take (4 * 256) -> [[x, y, z, w], [x, y, z, w] ... ] -> map readInt
drop (4 * 256)

ghc の readFile あるいはその下の getContents の制限がある。
そこらへんをなんとかしなくてはならない。
メモリ量の問題だと思うけど。

2013.03.16 Sat.

次やるとしたら、読み込みの型を指定すること、かな。
まあ、どの程度必要かはわからないけど、あれば便利であることは確かだ。

2013.03.22 Fri.

うまく作れば、読み込みの型を String と ByteString の両方に対応させることは可能だ。
read のほうは、take と drop と、それと toString と readInt あたりを class Str の
関数にすればいいはずだ。

段階的に作っていこう。
まずは、
class Str a where
	tk :: Int -> a -> a
	dp :: Int -> a -> a
	ts :: a -> String
	ti :: a -> Int

次は
4<(Int, Int, Int)>[colorIndexNumber]: colors
の実装をしよう。

それと読み捨ても必要だ。

2013.03.23 Sat.

tuple の数だけ変数を作る。
map f [その変数]
それを listE でまとめて、appE (varE 'cc) でつなげる。

また、それを let (その変数) = exp in (here) の here に入れる。

2013.03.24 Sun.
次は 1bit 単位での読み書きに対応したい。
例えば、

4bit: some

のような感じか。

また整数型も Int だけではなく様々な整数型に対応したい。

または、より一般的に class として、多くの型に対応できるようにするか。
入力の型についても class Binary とでもして、その型を公開しておけば、
ユーザーが定義した Binary 型からの入力が可能となる。
ここらへんは良さそうだな。
FlexibleInstances を利用すれば (Int, Int, Int) も可能だろうし。

その前にコードの整理が必要かもしれない。

2013.03.25 Mon.

big endian への対応が必要。

set big_endian とかかな
set littele_endian とか。
また一時的に変化させるために、
4(BE): hoge
のような書きかたを使おうかな。
まずは、set big_endian を使ってみよう。
