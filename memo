binary file の reader と writer を作ろう。
template Haskell と quasi quotation を活用することにする。
まずは簡単な例から。

data 構造と reader を自動生成するようにする。
つまり、
[binary|

BitmapFileHeader

2: 19778
4: fileSize
2: 0
2: 0
4: offset

|]

と書くと、

data BitmapFileHeader = BitmapFileHeader {
	fileSize :: Int,
	offset :: Int
 }

という構造と、

readBitmapFileHeader :: String -> BitmapFileHeader
readBitmapFileHeader cs = let
	cs' = if 19778 == readInt $ take 2 cs then drop 2 cs else error "bad"
	fs = readInt $ take 4 cs'
	cs'' = drop 4 cs'
	cs''' = if 0 == readInt $ take 2 cs'' then drop 2 cs'' else error "bad"
	cs'''' = if 0 == readInt $ take 2 cs''' then drop 2 cs''' else error "bad"
	os = readInt $ take 4 cs'''' in
	BitmapFileHeader {
		fileSize = fs,
		offset = os
	 }

という reader を生成するようにしたい。

まずは data 構造からだ。

次は連続する同一の構造への対応だ。

[binary|

BitmapFileHeader

2: 19778
4: fileSize
2: 0
2: 0
4: offset
4: 40
4: bitmapWidth
4: bitmapHeight
2: 1
2: bitPerPic
4: compress
4: imageDataSize
4: horizontalDensity
4: verticalDensity
4: colorIndexNumber
4: neededIndexNumber
4[colorIndexNumber]: colors

bitPerPic/8[imageDataSize*8/bitPerPic]: colors
bitPerPic b[imageDataSize*8/bitPerPic]: colors

|]

とすることにしよう。
また、それが難しかったら、まずは

[binary|

...
4[256]: colors

|]

という記述から始めようか。

また、行く行くは bytes ではなく bits でも指定できるようにしたい。

4b: some
4b: other
1: someOther

といった感じに。

あと空行を許すようにしよう。

4[256]: colors の場合:

take (4 * 256) -> [[x, y, z, w], [x, y, z, w] ... ] -> map readInt
drop (4 * 256)

ghc の readFile あるいはその下の getContents の制限がある。
そこらへんをなんとかしなくてはならない。
メモリ量の問題だと思うけど。			<- ちがった UTF-8 の問題だった。

2013.03.16 Sat.

次やるとしたら、読み込みの型を指定すること、かな。
まあ、どの程度必要かはわからないけど、あれば便利であることは確かだ。

2013.03.22 Fri.

うまく作れば、読み込みの型を String と ByteString の両方に対応させることは可能だ。
read のほうは、take と drop と、それと toString と readInt あたりを class Str の
関数にすればいいはずだ。

段階的に作っていこう。
まずは、
class Str a where
	tk :: Int -> a -> a
	dp :: Int -> a -> a
	ts :: a -> String
	ti :: a -> Int

次は
4<(Int, Int, Int)>[colorIndexNumber]: colors
の実装をしよう。

それと読み捨ても必要だ。

2013.03.23 Sat.

tuple の数だけ変数を作る。
map f [その変数]
それを listE でまとめて、appE (varE 'cc) でつなげる。

また、それを let (その変数) = exp in (here) の here に入れる。

2013.03.24 Sun.
次は 1bit 単位での読み書きに対応したい。
例えば、

4bit: some

のような感じか。

また整数型も Int だけではなく様々な整数型に対応したい。

または、より一般的に class として、多くの型に対応できるようにするか。
入力の型についても class Binary とでもして、その型を公開しておけば、
ユーザーが定義した Binary 型からの入力が可能となる。
ここらへんは良さそうだな。
FlexibleInstances を利用すれば (Int, Int, Int) も可能だろうし。

その前にコードの整理が必要かもしれない。

2013.03.25 Mon.

big endian への対応が必要。

set big_endian とかかな
set littele_endian とか。
また一時的に変化させるために、
4(BE): hoge
のような書きかたを使おうかな。
まずは、set big_endian を使ってみよう。

class RetType a where
	readRet :: Str b -> a

のようなクラスを作ろうかな。
それで FlexibleInstances を利用して、

instance (RecType a, RecType b) => RecType (a, b) where
	...

のような instance を 2 - 16 くらいまで作るのはどうか。

some_thing のような形を許す。
また、empty line と comment や複数の comment を許す。

PNG file のような構造を読むために、繰返しが必要かもしれない。
それと、16進数表記もあったほうがいいな。
また"\n\r" のような表記もできると便利だ。

[|

PNG

set big_endian

1: 137
3: "PNG"
1: 13
1: 10
1: 26
1: 10

repeat {

Chank

4: chankSize
4<String>: chankName
chankSize<String>: chankData
4<Word32>:chankCRC

}

|]

こんな感じ。

2013.03.26 Tue.

問題は、サイズを自分で決められないものと、逆に先に決められないものがあるということ。
解決策は、toType において、Maybe Int でサイズの引数を取るということだろう。
ただ、型の選択を含めた、より大きな解決策の一部とできないかという点に考慮が必要。
type family を使って、引数をそれぞれの型で決められるようにしておけば、
たとえば String 型を取って、それによってどの型を読み込むか決めることができそうに思う。

4<Int>: chankSize
4<String>: chankName
(chankSize, chankName)<ManyChanks>: chankBody
4<Word32>:chankCRC

こんな感じにしておき、

class RetType r where
	type Argument r
	fromType :: Str s => r -> s
	toType :: Argument r -> s -> (r, s)

instance RetType ManyChanks where
	type Argument ManyChanks = (Int, String)
	fromType (Chank1 c1) = fromType c1
	toType (n, "Chank1") = Chank1 $ toType n c1

これは良さげだな。

Classes は別に読めるようにしておいたほうが便利かもしれない。
そうすれば String, Int 等に独自の実装ができる。
別々でも読めるけど、File.Binary はそれを set で読み込むようにしておこうかな。
File.Binary.Types と File.Binary.Quote を作り、File.Binary
がそれら両方を読むことにする。
あるいは、File.Binary.Types.LittleEndian と、File.Binary.Types.BigEndian とか。

外部からの argument を読み込めるようにする。
つまり、fromType や toType がそのまま write... や read... となるようにする?
その場合、引数の型を指定してやる必要がある。

Parser で、
	/ 'arg'		{ \ret arg -> arg }
のようにする。
そうしておいて、expression を評価するときに、引数として newName したものを与える。
そして、その名前を read... や write... の引数として取らせる。

その前にひとつ、Expression を ExpQ にしてしまおう。
まずは ExpressionQ にすべてまとめるところから。
